# Makefile.tests for AV-PeerZMQ Project Test Suite

# Variables
# -----------------------------------------------------------------------------
NLOHMANN_JSON_HPP := third_party/nlohmann/json.hpp
CXX ?= g++
RM ?= rm -f
PKG_CONFIG ?= pkg-config

TEST_TARGET := test_mesh_network
LIB_SRCS := mesh_network.cpp
TEST_SRCS := test_mesh_network.cpp

# Generate object file names
LIB_OBJS := $(LIB_SRCS:.cpp=.o) # Should be mesh_network.o
TEST_OBJS := $(TEST_SRCS:.cpp=.o) # Should be test_mesh_network.o
OBJS := $(LIB_OBJS) $(TEST_OBJS)

# Compiler and Linker Flags
# -----------------------------------------------------------------------------
# Base flags
BASE_CXXFLAGS := -std=c++17 -Wall -pthread -g # Changed to C++17, kept -g
BASE_LDFLAGS := -pthread
BASE_LDLIBS := -pthread # -pthread can also be needed for linking with g++

# Attempt to use pkg-config for ZeroMQ
PKG_CONFIG_ZEROMQ_CFLAGS := $(shell $(PKG_CONFIG) --cflags libzmq 2>/dev/null || $(PKG_CONFIG) --cflags zeromq 2>/dev/null)
PKG_CONFIG_ZEROMQ_LIBS := $(shell $(PKG_CONFIG) --libs libzmq 2>/dev/null || $(PKG_CONFIG) --libs zeromq 2>/dev/null)

# Initialize CXXFLAGS and LDFLAGS/LDLIBS
CXXFLAGS := $(BASE_CXXFLAGS) -Ithird_party # Add include for nlohmann/json.hpp
LDFLAGS := $(BASE_LDFLAGS)
LDLIBS := $(BASE_LDLIBS)

# If pkg-config provided CFLAGS for ZeroMQ, add them
ifeq ($(strip $(PKG_CONFIG_ZEROMQ_CFLAGS)),)
    $(info Warning: pkg-config could not find ZeroMQ cflags for tests. Using default include path.)
    CXXFLAGS += $(INC_PATHS) -I/usr/local/include # INC_PATHS for manual override
else
    CXXFLAGS += $(PKG_CONFIG_ZEROMQ_CFLAGS)
endif

# If pkg-config provided LIBS for ZeroMQ, add them
ifeq ($(strip $(PKG_CONFIG_ZEROMQ_LIBS)),)
    $(info Warning: pkg-config could not find ZeroMQ libs for tests. Using default lib path and lib name.)
    LDFLAGS += $(LIB_PATHS) -L/usr/local/lib # LIB_PATHS for manual override
    LDLIBS += -lzmq
else
    LDFLAGS += $(filter -L%, $(PKG_CONFIG_ZEROMQ_LIBS))
    LDLIBS += $(filter-out -L%, $(PKG_CONFIG_ZEROMQ_LIBS))
endif

# Targets
# -----------------------------------------------------------------------------
.PHONY: build_tests clean_tests

# Rule to download nlohmann/json.hpp
$(NLOHMANN_JSON_HPP):
	@echo "Downloading nlohmann/json.hpp (for tests)..."
	@mkdir -p $(dir $(NLOHMANN_JSON_HPP))
	@curl -L https://github.com/nlohmann/json/releases/download/v3.11.3/json.hpp -o $(NLOHMANN_JSON_HPP)
	@echo "Downloaded nlohmann/json.hpp."

# Default target
build_tests: $(TEST_TARGET)

# Rule to link the test executable
$(TEST_TARGET): $(OBJS) $(NLOHMANN_JSON_HPP)
	@echo "Linking test target: $@"
	$(CXX) $(LDFLAGS) $^ -o $@ $(LDLIBS)

# Explicit rules for object file compilation (as per requirement examples)
# These will recompile mesh_network.o for the tests, ensuring independence.
$(LIB_OBJS): $(LIB_SRCS) mesh_network.h $(NLOHMANN_JSON_HPP)
	@echo "Compiling library source for tests: $<"
	$(CXX) $(CXXFLAGS) -c $< -o $@

$(TEST_OBJS): $(TEST_SRCS) mesh_network.h $(NLOHMANN_JSON_HPP)
	@echo "Compiling test source: $<"
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Clean target for tests
clean_tests:
	@echo "Cleaning test objects and target..."
	$(RM) $(TEST_TARGET) $(OBJS)
	@echo "Test clean complete."

# Informative echo (optional for debugging Makefile)
# $(info Using CXXFLAGS for tests: $(CXXFLAGS))
# $(info Using LDFLAGS for tests: $(LDFLAGS))
# $(info Using LDLIBS for tests: $(LDLIBS))
# $(info Test OBJS: $(OBJS))
